import Foundation
import Testing
@testable import VPStudio

/// Tests for auto-open environment decision logic.
///
/// The actual `autoOpenEnvironmentIfNeeded()` method is private to PlayerView and requires
/// visionOS ImmersiveSpace APIs, so we test the extracted decision components:
/// - Settings key existence and default value
/// - Immersive space ID routing for different asset types
/// - Asset selection and state checks
@Suite(.serialized)
struct EnvironmentAutoOpenTests {

    // MARK: - Settings Key

    @Test func autoOpenEnvironmentSettingsKeyExists() {
        #expect(SettingsKeys.autoOpenEnvironment == "auto_open_environment")
    }

    @Test func autoOpenEnvironmentDefaultsToTrue() async throws {
        let rootDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString, isDirectory: true)
        try FileManager.default.createDirectory(at: rootDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: rootDir) }

        let dbURL = rootDir.appendingPathComponent("auto-open-default.sqlite")
        let database = try DatabaseManager(path: dbURL.path)
        try await database.migrate()
        let settings = SettingsManager(database: database, secretStore: TestSecretStore())

        let value = try await settings.getBool(key: SettingsKeys.autoOpenEnvironment, default: true)
        #expect(value == true, "Auto-open should default to true when not set")
    }

    @Test func autoOpenEnvironmentCanBeDisabled() async throws {
        let rootDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString, isDirectory: true)
        try FileManager.default.createDirectory(at: rootDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: rootDir) }

        let dbURL = rootDir.appendingPathComponent("auto-open-disabled.sqlite")
        let database = try DatabaseManager(path: dbURL.path)
        try await database.migrate()
        let settings = SettingsManager(database: database, secretStore: TestSecretStore())

        try await settings.setBool(key: SettingsKeys.autoOpenEnvironment, value: false)
        let value = try await settings.getBool(key: SettingsKeys.autoOpenEnvironment, default: true)
        #expect(value == false, "Auto-open should be disabled after setting to false")
    }

    @Test func autoOpenEnvironmentCanBeReEnabled() async throws {
        let rootDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString, isDirectory: true)
        try FileManager.default.createDirectory(at: rootDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: rootDir) }

        let dbURL = rootDir.appendingPathComponent("auto-open-reenable.sqlite")
        let database = try DatabaseManager(path: dbURL.path)
        try await database.migrate()
        let settings = SettingsManager(database: database, secretStore: TestSecretStore())

        try await settings.setBool(key: SettingsKeys.autoOpenEnvironment, value: false)
        try await settings.setBool(key: SettingsKeys.autoOpenEnvironment, value: true)
        let value = try await settings.getBool(key: SettingsKeys.autoOpenEnvironment, default: true)
        #expect(value == true, "Auto-open should be re-enabled after toggling back")
    }

    // MARK: - Immersive Space ID Routing (used by auto-open)

    @Test func hdriAssetRoutesToHdriSkyboxSpace() async throws {
        let rootDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString, isDirectory: true)
        try FileManager.default.createDirectory(at: rootDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: rootDir) }

        let dbURL = rootDir.appendingPathComponent("auto-open-hdri-routing.sqlite")
        let database = try DatabaseManager(path: dbURL.path)
        try await database.migrate()
        let manager = EnvironmentCatalogManager(database: database)

        let asset = EnvironmentAsset(
            id: "hdri-1",
            name: "Cinema HDRI",
            sourceType: .imported,
            assetPath: "/tmp/cinema.hdr"
        )
        let spaceID = await manager.immersiveSpaceID(for: asset)
        #expect(spaceID == "hdriSkybox")
    }

    @Test func bundledAssetWithNoExtensionRoutesToCustomEnvironment() async throws {
        let rootDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString, isDirectory: true)
        try FileManager.default.createDirectory(at: rootDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: rootDir) }

        let dbURL = rootDir.appendingPathComponent("auto-open-bundled-routing.sqlite")
        let database = try DatabaseManager(path: dbURL.path)
        try await database.migrate()
        let manager = EnvironmentCatalogManager(database: database)

        let asset = EnvironmentAsset(
            id: "bundled-1",
            name: "Bundled",
            sourceType: .bundled,
            assetPath: "some-asset"
        )
        let spaceID = await manager.immersiveSpaceID(for: asset)
        #expect(spaceID == "customEnvironment")
    }

    @Test func usdzAssetRoutesToCustomEnvironmentSpace() async throws {
        let rootDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString, isDirectory: true)
        try FileManager.default.createDirectory(at: rootDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: rootDir) }

        let dbURL = rootDir.appendingPathComponent("auto-open-usdz-routing.sqlite")
        let database = try DatabaseManager(path: dbURL.path)
        try await database.migrate()
        let manager = EnvironmentCatalogManager(database: database)

        let asset = EnvironmentAsset(
            id: "usdz-1",
            name: "Custom Model",
            sourceType: .imported,
            assetPath: "/tmp/model.usdz"
        )
        let spaceID = await manager.immersiveSpaceID(for: asset)
        #expect(spaceID == "customEnvironment")
    }

    @Test func exrAssetRoutesToHdriSkyboxSpace() async throws {
        let rootDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString, isDirectory: true)
        try FileManager.default.createDirectory(at: rootDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: rootDir) }

        let dbURL = rootDir.appendingPathComponent("auto-open-exr-routing.sqlite")
        let database = try DatabaseManager(path: dbURL.path)
        try await database.migrate()
        let manager = EnvironmentCatalogManager(database: database)

        let asset = EnvironmentAsset(
            id: "exr-1",
            name: "EXR Skybox",
            sourceType: .imported,
            assetPath: "/tmp/skybox.exr"
        )
        let spaceID = await manager.immersiveSpaceID(for: asset)
        #expect(spaceID == "hdriSkybox")
    }

    // MARK: - Active Asset Selection (used by auto-open)

    @Test func noActiveAssetMeansNoAutoOpen() async throws {
        let rootDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString, isDirectory: true)
        try FileManager.default.createDirectory(at: rootDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: rootDir) }

        let dbURL = rootDir.appendingPathComponent("auto-open-no-active.sqlite")
        let database = try DatabaseManager(path: dbURL.path)
        try await database.migrate()
        let manager = EnvironmentCatalogManager(database: database)

        let active = try await manager.activeAsset()
        #expect(active == nil, "No active asset before bootstrap means auto-open has nothing to open")
    }

    @Test func bootstrappedEmptyCatalogHasNoActiveAsset() async throws {
        let rootDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString, isDirectory: true)
        try FileManager.default.createDirectory(at: rootDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: rootDir) }

        let dbURL = rootDir.appendingPathComponent("auto-open-bootstrapped.sqlite")
        let database = try DatabaseManager(path: dbURL.path)
        try await database.migrate()
        let manager = EnvironmentCatalogManager(database: database)
        try await manager.bootstrapCuratedAssets()

        let active = try await manager.activeAsset()
        #expect(active == nil, "With no curated defaults, bootstrap produces no active asset â€” user must import one")
    }

    @Test func importedAssetBecomesActiveAfterActivation() async throws {
        let rootDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString, isDirectory: true)
        try FileManager.default.createDirectory(at: rootDir, withIntermediateDirectories: true)
        defer { try? FileManager.default.removeItem(at: rootDir) }

        let dbURL = rootDir.appendingPathComponent("auto-open-imported-active.sqlite")
        let database = try DatabaseManager(path: dbURL.path)
        try await database.migrate()
        let manager = EnvironmentCatalogManager(
            database: database,
            environmentsDirectory: rootDir.appendingPathComponent("env", isDirectory: true),
            assetValidator: { _ in true }
        )

        let source = rootDir.appendingPathComponent("cinema.hdr")
        try Data("fake-hdr".utf8).write(to: source)
        let imported = try await manager.importEnvironment(from: source)
        try await manager.activateAsset(id: imported.id)

        let active = try await manager.activeAsset()
        #expect(active != nil, "After importing and activating, there should be an active asset for auto-open")
        #expect(active?.id == imported.id)
    }
}
